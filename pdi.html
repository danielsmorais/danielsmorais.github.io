<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8"> <![endif]-->  
<!--[if IE 9]> <html lang="en" class="ie9"> <![endif]-->  
<!--[if !IE]><!--> <html lang="en"> <!--<![endif]-->  
<head>
    <title>Daniel Morais</title>
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">    
    <link rel="shortcut icon" href="assets/images/favicon.ico">  
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <!-- Global CSS -->
    <link rel="stylesheet" href="assets/plugins/bootstrap/css/bootstrap.min.css">   
    <!-- Plugins CSS -->   
    <link rel="stylesheet" href="assets/plugins/prism/prism.css">
    <link rel="stylesheet" href="assets/plugins/font-awesome/css/font-awesome.css">    
    <link rel="stylesheet" href="assets/plugins/elegant_font/css/style.css">
    
    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/styles.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
</head> 

<body class="body-green">
    <div class="page-wrapper">
        <!-- ******Header****** -->
        <header id="header" class="header">
            <div class="container">
                <div class="branding">
                    <h1 class="logo">
                        <a href="index.html">
                            <span aria-hidden="true" class="icon_documents_alt icon"></span>
                            <span class="text-highlight">Daniel</span><span class="text-bold">Morais</span>
                        </a>
                    </h1>
                </div><!--//branding-->
                <ol class="breadcrumb">
                    <li><a href="index.html">Home</a></li>
                    <li class="active">PDI</li>
                </ol>
            </div><!--//container-->
        </header><!--//header-->
        <div class="doc-wrapper">
            <div class="container">
                <div id="doc-header" class="doc-header text-center">
                    <h1 class="doc-title"><i class="icon fa fa-file-image-o"></i> Processamento Digital de Imagens</h1>
                    <div class="meta"><i class="fa fa-clock-o"></i> Last updated: March 31th, 2017</div>
                </div><!--//doc-header-->
                <div class="doc-body">
                    <div class="doc-content">
                        <div class="content-inner">
                        
                        
                            <section id="about-section" class="doc-section">
                            
                                <h2 class="section-title">About</h2>
                                <div class="section-block">
                                    <p>Esta página é destinada ao relatório dos exercícios realizados para a Disciplina de Processamento Digital de Imagens - DCA/UFRN.</p>
                                    
                                    <h6>Discentes Envolvidos:</h6>                                    
                                    
                                    <ul class="list">
                                        <li>Daniel Silva de Morais | danielmorais@outlook.com.br</li>
                                        <li>Gabriel Felipe Azevedo de Sousa | g.felipes@hotmail.com</li>                               
                                    </ul>                             

                                </div>
                            </section><!--//doc-section-->
                                                        
                            
                            <section id="1unidade-section" class="doc-section">
                            
                                <h2 class="section-title">1ª Unidade</h2>
                                <div id="step1"  class="section-block">
                                    <h1 class="block-title">Exercício 3 - Manipulando pixels em uma imagem</h1>

                                    <h3 class="block-title">3.1 - Área negativa de uma imagem </h3>
                                    <p><i>
                                    Utilizando o programa <a href="PDI/3/pixels.cpp">pixels.cpp</a> como referência, implemente um programa regions.cpp. Esse programa deverá solicitar ao usuário as coordenadas de dois pontos P<SUB>1</SUB> e P<SUB>2</SUB> localizados dentro dos limites do tamanho da imagem e exibir que lhe for fornecida. Entretanto, a região definida pelo retângulo de vértices opostos definidos pelos pontos P<SUB>1</SUB> e P<SUB>2</SUB> será exibida com o negativo da imagem na região correspondente.
                                    </i></p>
                                    
                                    <p>
                                    Para o desenvolvimento da aplicação, foi utilizado o programa <a href="PDI/3/pixels.cpp">pixels.cpp</a> como referência. Ao executar o código no terminal do linux utilizando do arquivo <a href="PDI/3/Makefile">Makefile</a>, é solicitado que o usuário dê entrada para dois pontos, P<SUB>1</SUB> e P<SUB>2</SUB>, com as coordenadas <i>x</i> e <i>y</i>. O resultado pode ser visto a seguir:
                                    </p>
                                    
                                    <div clas="code-block">
                                    <h6>Código: <a href="PDI/3/regions.cpp">regions.cpp</a></h6>
                                    <pre><code class="language-c++">
	
#include &#60;iostream&#62;
#include &#60;cv.h&#62;
#include &#60;highgui.h&#62;
#include &#60;opencv2/opencv.hpp&#62;


using namespace cv;
using namespace std;


int main(int, char**){

    Mat image, image2;    
    image = imread("../imagens/biel.png", CV_LOAD_IMAGE_GRAYSCALE);
    image2 = image.clone();

    if(!image.data)
        cout << "Não foi possível abrir ou encontrar a imagem." << endl;
    
    Point p1, p2;
    
    cout << "Informe as coordenadas de dois pontos entre (0, 0) e (255, 255):" << endl;
    do{
        cout << "P1.x: ";
        cin >> p1.x;
        cout << "P1.y: ";
        cin >> p1.y;        
        cout << "P2.x: ";
        cin >> p2.x;
        cout << "P2.y: ";
        cin >> p2.y;        
    }while(p1.x > 255 || p1.x < 0 || p1.y > 255 || p1.y < 0 || 
           p2.x > 255 || p2.x < 0 || p2.y > 255 || p2.y < 0 || 
           p1.x > p2.x || p1.y > p2.y);
    
    cout << "Pontos selecionados: "<< "P1("<< p1.x <<", "<< p1.y<<") e P2("<< p2.x<<", "<< p2.y<<")"<< endl;      
       
    for(int i=p1.x;i < p2.x;i++){
        for(int j=p1.y;j < p2.y;j++){
            image2.at< uchar >(i,j) = 255 - image2.at< uchar >(i,j);
        }
    }
    
    namedWindow("Imagem Original",WINDOW_AUTOSIZE);
    imshow("Imagem Original", image);
    
    namedWindow("Imagem Negativo",WINDOW_AUTOSIZE);
    imshow("Imagem Negativo", image2);
    waitKey(0);
    
    return 0;
}                             
                                
                                </code></pre>
                                </div>                                 
                                    
                                    
                                <div class="section-block">

                                        <h6>Figura 1 - Terminal</h6>
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/3/terminal-regions.png" alt="screenshot"></a>                                                
                                        </div>                   
                                </div><!--//section-block-->
                                    
                                <div class="section-block">

                                        <h6>Figura 2 - Resultado</h6>
                                        <p>Comparação entre a imagem original e a imagem com a região em negativo</p>
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/3/biel1.png" alt="screenshot"></a>                                                
                                        </div>                   
                                </div><!--//section-block-->                                
                                
                                
                                <div class="section-block">
                                    <h3 class="block-title">3.2 - Troca regiões</h3>                                    
                                    <p><i>Utilizando o programa <a href="PDI/3/pixels.cpp">pixels.cpp</a> como referência, implemente um programa <code>trocaregioes.cpp</code>. Seu programa deverá trocar os quadrantes em diagonal na imagem. Explore o uso da classe <code>Mat</code> e seus construtores para criar as regiões que serão trocadas.
                                    </i></p> 
                                    
                                    <p>
                                    Para o desenvolvimento da aplicação, foram criados quatro regiões de interesse, de forma que podemos manipulá-las para obtermos o efeito desejado. A seguir segue o código desenvolvido:
                                    </p>     
                                    
                                    
                                <div clas="code-block">
                                <h6>Código: <a href="PDI/3/regions.cpp">regions.cpp</a></h6>
                                <pre><code class="language-c++">
#include &#60;iostream&#62;
#include &#60;cv.h&#62;
#include &#60;highgui.h&#62;
#include &#60;opencv2/opencv.hpp&#62;

using namespace cv;
using namespace std;


int main(int, char **)
{

    Mat image, aux, aux2;
    image = imread("../imagens/biel.png", CV_LOAD_IMAGE_GRAYSCALE);

    if (!image.data) 
	{
        cout << "Não foi possível abrir ou encontrar a imagem." << endl;
        return 0;
    }

    aux = image(Rect(0, 0, 128, 128)).clone();              //Rect(x0, y0, x, y ) x e y é o quanto eu quero pegar
    aux2 = image(Rect(128, 128, 128, 128)).clone();
    //TROCA DE REGIÕES
    aux.copyTo(image(Rect(128, 128, 128, 128)));
    aux2.copyTo(image(Rect(0, 0, 128, 128)));
    
    aux = image(Rect(0, 128, 128, 128)).clone();            //Rect(x0, y0, x, y ) x e y é o quanto eu quero pegar        
    aux2 = image(Rect(128, 0, 128, 128)).clone();
    //TROCA DE REGIÕES
    aux.copyTo(image(Rect(128, 0, 128, 128)));
    aux2.copyTo(image(Rect(0, 128, 128, 128)));

    namedWindow("Imagem", WINDOW_AUTOSIZE);
    imshow("Imagem", image);

    waitKey(0);

    return 0;
}                        
                                
                                </code></pre>
                                </div>
                                </br>
                                <p>Para facilitar na programação, foi utilizado o método <code>Rect()</code>, que permite fazer uma cópia dos pixels de uma determinada área da imagem que é especificada como parâmetro. Executando o código, obtemos o seguinte efeito:</p>    
                                <div class="section-block">

                                        <h6>Figura 3 - Regiões trocadas</h6>
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/3/biel2.png" alt="screenshot"></a>                                                
                                        </div>                   
                                </div><!--//section-block-->
                              
                                </div>
                                    
                                    
                                    
                                
                                    

                                
                                 <div id="step2"  class="section-block">
                                
                                    <h1 class="block-title">Exercício 4 - Preenchendo regiões</h1>
                                    <h3 class="block-title">4.1 - Questão </h3>
                                    <p><i>
                                    Observando-se o programa <a href="PDI/4/labeling.cpp">labeling.cpp</a> como exemplo, é possível verificar que caso existam mais de 255 objetos na cena, o processo de rotulação poderá ficar comprometido. Identifique a situação em que isso ocorre e proponha uma solução para este problema.
                                    </i></p> 
                                    <p>Como a imagem é composta por pixels de 8 bits, por ser tom de cinza a imagem poderá ter 256 diferentes tons. Retirando a cor de fundo (preta), temos 255 tons de cinza. Logo, se tivermos mais de 255 objetos não será possível rotulá-los na imagem. O interessante seria especificar um tom de cinza diferente de 0 e 255 e rotular todos os objetos com o mesmo tom. Com isso, não importa a quantidade de objetos.</p>
                                    
                                    <h3 class="block-title">4.2 - Contagem de objetos </h3>
                                    <p><i>
                                    Aprimore o algoritmo de contagem apresentado para identificar regiões com ou sem buracos internos que existam na cena. Assuma que objetos com mais de um buraco podem existir. Inclua suporte no seu algoritmo para não contar bolhas que tocam as bordas da imagem. Não se pode presumir, a priori, que elas tenham buracos ou não.
                                    </i></p>
                                    <p>
                                    Uma forma de contar o número de buracos é através de rótulos, ou seja, como os buracos possuem o mesmo tom de cinza do fundo, podemos alterar a cor de fundo e buscar os buracos das bolhas, que terão seu tom de cinza igual ao do fundo original (0). Com o auxílio do método <code>floodFill()</code> podemos encontrar essas regiões e fazer sua contagem.
                                    </p>
                                    
                                    <div clas="code-block">
                                    <h6>Código: <a href="PDI/4/contaregiao.cpp">contaregiao.cpp</a></h6>
                                    <pre><code class="language-c++">
#include &#60;iostream&#62;
#include &#60;cv.h&#62;
#include &#60;highgui.h&#62;
#include &#60;opencv2/opencv.hpp&#62;

using namespace cv;
using namespace std;

int main(int argc, char **argv)
{
    Mat image, mask;
    int width, height;
    int nobjects, noburacos;

    CvPoint p;
    image = imread("../imagens/bolhas.png", CV_LOAD_IMAGE_GRAYSCALE);

    if (!image.data) {
        cout << "imagem nao carregou corretamente\n";
        return (-1);
    }
    width = image.size().width;         //colunas
    height = image.size().height;       //linhas

    p.x = 0;
    p.y = 0;
    
    // Elimina os objetos que tocam as laterais da imagem, rotulando-os com a cor de fundo;
    for (int k = 0; k < height; k++) {
        floodFill(image, CvPoint(k,0), 0);
        floodFill(image, CvPoint(k,255), 0);
        floodFill(image, CvPoint(0,k), 0);
        floodFill(image, CvPoint(255,k), 0);
    }
    

    // Contagem de objetos
    nobjects = 0;
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            if (image.at < uchar > (i, j) == 255) {
                // achou um objeto
                nobjects++;
                p.x = j;
                p.y = i;

                //Todos os objetos são rotulados no tom de cinza 200;
                floodFill(image, p, 200);
            }
        }
    }    
    
    // Contagem de objetos com buracos
    //Uma forma de contar o número de buracos é através de rótulos, ou seja, como os buracos 
    //possuem o mesmo tom de cinza do fundo, podemos alterar a cor de fundo e buscar os objetos, 
    //que terão seu tom de cinza igual ao do fundo. Depois podemos bunscar na imagem o número de 
    //regiões de tom de cinza 0, que equivale ao buraco.
    
    floodFill(image,cvPoint(0,0), 50);                  // utilizando o floodFill(), mudaremos a cor de fundo
    
    noburacos = 0;
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            if (image.at < uchar > (i, j) == 0) {       //busca objetos da cor de fundo original
                p.x = j;
                p.y = i;
                //Todos os buracos são rotulados no tom de cinza 50;
                floodFill(image, p, 50);
                
                if(image.at< uchar>(i, j-1) == 200)
                {
                    noburacos++;
                    // preenche objeto com buraco com cor diferente, de forma que se acharmos um novo buraco e 
                    //um pixel anterior for de cor diferente de 200, ele irá saber que a bolha possui outros 
                    //buracos e não contabilizará novos buracos para aquela bolha.
                    floodFill(image,cvPoint(p.x-1,p.y), 150);
                }
            }
        }
    }  
    
    cout << "Número de objetos: " << nobjects << endl;
    cout << "Número de buracos: " << noburacos << endl;
    cout << "Número de objetos sem buracos: " << nobjects - noburacos << endl;   
    

    imshow("image", image);
    imwrite("labeling.png", image);
    waitKey();
    return 0;
}                       
                                    
                                    </code></pre>
                                    </div>
                                    </br>
                                    <p>
                                    Para testar o código, utilizaremos a Figura 4, que é formada por um fundo preto (0) e bolhas em tom branco (255).
                                    </p>                                    
                                    
                                    <div class="section-block">
                                        <h6>Figura 4 - Bolhas</h6>                                        
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/imagens/bolhas.png" alt="screenshot"></a>                                                
                                        </div>                   
                                    </div><!--//section-block-->
                                    
                                    <div class="section-block">
                                        <h6>Figura 5 - Contagem de bolhas</h6> 
                                        <p>Algoritmo modificado, logo um pouco diferente do labeling.cpp</p>
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/4/labeling1.png" alt="screenshot"></a>                                                
                                        </div>                   
                                    </div><!--//section-block--> 
                                    
                                    <div class="section-block">
                                        <h6>Figura 6 - Contagem de bolhas e buracos</h6> 
                                        <p>Resultado</p>
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/4/contaregiao.png" alt="screenshot"></a>                                                
                                        </div>                   
                                    </div><!--//section-block-->                                     
                                 </div>
                                

                                 <div id="step3"  class="section-block">
                                
                                    <h1 class="block-title">Exercício 5 - Manipulação de histogramas</h1>
                                    <h3 class="block-title">5.1 - Equalização de histograma </h3>
                                    <p><i>                                    
                                    Utilizando o programa <a href="PDI/5/histogram.cpp">histogram.cpp</a> como referência, implemente um programa <code>equalize.cpp</code>. Este deverá, para cada imagem capturada, realizar a equalização do histogram antes de exibir a imagem. Teste sua implementação apontando a câmera para ambientes com iluminações variadas e observando o efeito gerado. Assuma que as imagens processadas serão em tons de cinza.
                                    </i></p> 
                                    <p>
                                    A equalização de histograma é um método que permite mudar a distribuição dos valores de ocorrência em um histograma permitindo uma redução das diferenças acentuadas de tons e assim, particularmente em imagens, acentuando detalhes não visíveis anteriormente.</p>
                                    <p>Para a realização da aplicação, foi utilizado o exemplo de referência. Dessa forma, temos o seguinte código:</p>
                                    
                                    <div clas="code-block">
                                    <h6>Código: <a href="PDI/5/equalize.cpp">equalize.cpp</a></h6>
                                    <pre><code class="language-c++">
#include &#60;iostream&#62;
#include &#60;cv.h&#62;
#include &#60;highgui.h&#62;
#include &#60;opencv2/opencv.hpp&#62;
#include "opencv2/imgproc/imgproc.hpp"

using namespace cv;
using namespace std;

int main(int argc, char** argv){
  Mat image;
  int width, height;
  VideoCapture cap;
    
  vector< Mat> planes;
  Mat histR, histG, histB;
  int nbins = 64;
  float range[] = {0, 256};
  const float *histrange = { range };
  bool uniform = true;
  bool acummulate = false;

  cap.open(0);  //seleciona a camera
  
  
  if(!cap.isOpened()){
    cout << "cameras indisponiveis";
    return -1;
  }
  
  width  = cap.get(CV_CAP_PROP_FRAME_WIDTH);
  height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);

  cout << "largura = " << width << endl;
  cout << "altura  = " << height << endl;

  int histw = nbins, histh = nbins/2;
  Mat histImgR(histh, histw, CV_8UC3, Scalar(0,0,0));
  Mat histImgG(histh, histw, CV_8UC3, Scalar(0,0,0));
  Mat histImgB(histh, histw, CV_8UC3, Scalar(0,0,0));
  
  while(1){   
    
    cap >> image;
    //Redimensionar a captura
    resize(image, image, Size(640, 360));
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    // EQUALIZAÇÃO
    /////////////////////////////////////////////////////////////////////////////////////////////////// 
    
    //Separa a imagem capturada em três canais que são armazenados em "planes" 
    split (image, planes);  
    
    //Equalização das capturas
    equalizeHist(planes[0], planes[0]);
    equalizeHist(planes[1], planes[1]);
    equalizeHist(planes[2], planes[2]);    
        
    //Utilizamos  a função merge() para unir os planos ou canais equalizados em image.
    merge(planes, image);   
    
    /////////////////////////////////////////////////////////////////////////////////////////////////// 
    
    
    calcHist(&planes[0], 1, 0, Mat(), histR, 1,
             &nbins, &histrange,
             uniform, acummulate);
    calcHist(&planes[1], 1, 0, Mat(), histG, 1,
             &nbins, &histrange,
             uniform, acummulate);
    calcHist(&planes[2], 1, 0, Mat(), histB, 1,
             &nbins, &histrange,
             uniform, acummulate);

    normalize(histR, histR, 0, histImgR.rows, NORM_MINMAX, -1, Mat());
    normalize(histG, histG, 0, histImgG.rows, NORM_MINMAX, -1, Mat());
    normalize(histB, histB, 0, histImgB.rows, NORM_MINMAX, -1, Mat());

    histImgR.setTo(Scalar(0));
    histImgG.setTo(Scalar(0));
    histImgB.setTo(Scalar(0));
    
    for(int i=0; i < nbins; i++){
      line(histImgR,
           Point(i, histh),
           Point(i, histh-cvRound(histR.at< float>(i))),
           Scalar(0, 0, 255), 1, 8, 0);
      line(histImgG,
           Point(i, histh),
           Point(i, histh-cvRound(histG.at< float>(i))),
           Scalar(0, 255, 0), 1, 8, 0);
      line(histImgB,
           Point(i, histh),
           Point(i, histh-cvRound(histB.at< float>(i))),
           Scalar(255, 0, 0), 1, 8, 0);
    }
    histImgR.copyTo(image(Rect(0, 0       ,nbins, histh)));
    histImgG.copyTo(image(Rect(0, histh   ,nbins, histh)));
    histImgB.copyTo(image(Rect(0, 2*histh ,nbins, histh)));
    imshow("image", image);
    if(waitKey(30) >= 0) break;
  }
  return 0;
}                       
 
                                    </code></pre>
                                    </div>
                                    
                                    </br>
                                    <p>
                                    O cálculo do histograma será realizado para cada uma das componentes de cor de forma independente. Logo, a separação das componentes em matrizes independentes será feita no vetor de matrizes <code>planes</code>. Assim, <code>planes[0]</code>, <code>planes[1]</code> e <code>planes[2]</code> armazenarão as componentes de cor Vermelho, Verde e Azul, respectivamente. É utilizado o método <code>split()</code> para a separação dos componentes de cor. Para fazer a equalização, é utilizado o método <code>equalizeHist()</code>, que é do OpenCV, ele é utilizado para todas as componentes da imagem em captura. Para finalizar, é utilizado o método <code>merge()</code> para unir os planos e formar a nova imagem equalizada.                                   
                                    </p>
                                    <p>
                                    A seguir, a Figura 7 mostra a captura sem equalização e a Figura 8 mostra o resultado da equalização.
                                    </p>

                                    <div class="section-block">
                                        <h6>Figura 7 - Captura sem equalização</h6> 
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/5/histogram.png" alt="screenshot"></a>                                                
                                        </div>                   
                                    </div><!--//section-block--> 
                                    
                                    <div class="section-block">
                                        <h6>Figura 8 - Captura com equalização de histograma</h6> 
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/5/equalize.png" alt="screenshot"></a>                                                
                                        </div>                   
                                    </div><!--//section-block--> 
                                    
                                    <p>Podemos perceber no histograma que que o da figura 7 possui mais picos elevados do que o da Figura 8, isso ocorre devido a equalização.</p>             

                                    
                                    <h3 class="block-title">5.2 - Motion Detection </h3>
                                    <p><i>
                                    Utilizando o programa <a href="PDI/5/histogram.cpp">histogram.cpp</a> como referência, implemente um programa <code>motiondetector.cpp</code>. Este deverá continuamente calcular o histograma da imagem (apenas uma componente de cor é suficiente) e compará-lo com o último histograma calculado. Quando a diferença entre estes ultrapassar um limiar pré-estabelecido, ative um alarme. Utilize uma função de comparação que julgar conveniente.
                                    </i></p>
                                    <p>
                                    O Motion Detection ou detector de movimento, pode ser utilizado para diferentes aplicações, sendo a mais comum em serviços de segurança e monitoramento. Para Detectarmos movimento, foi utilizado o histograma da captura, sendo nescessário apenas de uma componente. Nesse caso, no início da captura foi armazenado um histograma, de forma que nas capturas seguintes elas são comparadas com a primeira captura, que está armazenada durante a execução da aplicação.
                                    </p>
                                    <p>
                                    Há um valor que é utilizado como limiar para sabermos se na variação do histograma houve um movimento grande movimento perceptível. A seguir, código desenvolvido.
                                    </p>
                                    
                                    <div clas="code-block">
                                    <h6>Código: <a href="PDI/5/equalize.cpp">equalize.cpp</a></h6>
                                    <pre><code class="language-c++">
#include &#60;iostream&#62;
#include &#60;cv.h&#62;
#include &#60;highgui.h&#62;
#include &#60;opencv2/opencv.hpp&#62;

using namespace cv;
using namespace std;

int main(int argc, char** argv){
  Mat image;
  int width, height;
  VideoCapture cap;  
  vector< Mat> planes;
  Mat hg_old, hg_new;  // histograma verde antigo e novo
  
  Mat histR, histG, histB;
  int nbins = 64;
  float range[] = {0, 256};
  const float *histrange = { range };
  bool uniform = true;
  bool acummulate = false;

  cap.open(0);
  
  
  if(!cap.isOpened()){
    cout << "cameras indisponiveis";
    return -1;
  }
  
  width  = cap.get(CV_CAP_PROP_FRAME_WIDTH);
  height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);

  cout << "largura = " << width << endl;
  cout << "altura  = " << height << endl;

  int histw = nbins, histh = nbins/2;
  Mat histImgR(histh, histw, CV_8UC3, Scalar(0,0,0));
  Mat histImgG(histh, histw, CV_8UC3, Scalar(0,0,0));
  Mat histImgB(histh, histw, CV_8UC3, Scalar(0,0,0));
  
  
  //As análises serão feitas utilizando o primeiro histograma, ou seja, da primeira imagem tirada do ambiente. 
  //Dessa forma, qualquer alteração dentro do limite x informará movimentação.
  cap >> image;
  split (image, planes);
  calcHist(&planes[1], 1, 0, Mat(), hg_old, 1, &nbins, &histrange, uniform, acummulate);
  
  double x = 0;
  
  while(1){
    cap >> image;
    resize(image, image, Size(640,360));
       
///////////////////////////////////////////////////////////////////////////////////////////////////    
    
    //DETECÇÃO DE MOVIMENTO
    
    split (image, planes);  

    calcHist(&planes[1], 1, 0, Mat(), hg_new, 1, &nbins, &histrange, uniform, acummulate);
    x = compareHist(hg_new, hg_old, CV_COMP_CORREL);
    
    cout << "x = "<< x<< endl;

    if(x<-0.25){
    	putText(image, "ALARME", cvPoint(250, 100), FONT_HERSHEY_COMPLEX_SMALL, 1, Scalar(255, 0, 0), 2);
    }
    
///////////////////////////////////////////////////////////////////////////////////////////////////    
    
    calcHist(&planes[0], 1, 0, Mat(), histR, 1,
             &nbins, &histrange,
             uniform, acummulate);
    calcHist(&planes[1], 1, 0, Mat(), histG, 1,
             &nbins, &histrange,
             uniform, acummulate);
    calcHist(&planes[2], 1, 0, Mat(), histB, 1,
             &nbins, &histrange,
             uniform, acummulate);

    normalize(histR, histR, 0, histImgR.rows, NORM_MINMAX, -1, Mat());
    normalize(histG, histG, 0, histImgG.rows, NORM_MINMAX, -1, Mat());
    normalize(histB, histB, 0, histImgB.rows, NORM_MINMAX, -1, Mat());

    histImgR.setTo(Scalar(0));
    histImgG.setTo(Scalar(0));
    histImgB.setTo(Scalar(0));
    
    for(int i=0; i < nbins; i++){
      line(histImgR,
           Point(i, histh),
           Point(i, histh-cvRound(histR.at< float>(i))),
           Scalar(0, 0, 255), 1, 8, 0);
      line(histImgG,
           Point(i, histh),
           Point(i, histh-cvRound(histG.at< float>(i))),
           Scalar(0, 255, 0), 1, 8, 0);
      line(histImgB,
           Point(i, histh),
           Point(i, histh-cvRound(histB.at< float>(i))),
           Scalar(255, 0, 0), 1, 8, 0);
    }
    histImgR.copyTo(image(Rect(0, 0       ,nbins, histh)));
    histImgG.copyTo(image(Rect(0, histh   ,nbins, histh)));
    histImgB.copyTo(image(Rect(0, 2*histh ,nbins, histh)));
    imshow("image", image);
    if(waitKey(30) >= 0) break;
  }
  return 0;
}                 
 
                                    </code></pre>
                                    </div>
                                    
                                    </br>                                    
                                    <div class="section-block">
                                        <h6>Gif 1 - Motion Detector</h6> 
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/5/video.gif" alt="screenshot"></a>                                                
                                        </div>                   
                                    </div><!--//section-block-->                                 
                                </div>
                                
     
     
     
                                 <div id="step4"  class="section-block">
                                
                                    <h1 class="block-title">Exercício 6 - Filtragem no domínio espacial I</h1>
                                    <p><i>                                    
                                    Utilizando o programa <a href="PDI/6/filtroespacial.cpp">filtroespacial.cpp</a> como referência, implemente um programa laplgauss.cpp. O programa deverá acrescentar mais uma funcionalidade ao exemplo fornecido, permitindo que seja calculado o laplaciano do gaussiano das imagens capturadas. Compare o resultado desse filtro com a simples aplicação do filtro laplaciano.
                                    </i></p> 
                                    <p>
                                    Utilizando o código de referência, obtemos alguns resultados. Aqui temos o código desenvolvido como a adição do filtro "Laplaciano do Gussiano":
                                    </p>                   
                                 
                                    
                                    <div clas="code-block">
                                    <h6>Código: <a href="PDI/6/laplgauss.cpp">laplgauss.cpp</a></h6>
                                    <pre><code class="language-c++">
#include &#60;iostream&#62;
#include &#60;opencv2/opencv.hpp&#62;

using namespace cv;
using namespace std;

void printmask(Mat & m)
{
    for (int i = 0; i < m.size().height; i++) {
        for (int j = 0; j < m.size().width; j++) {
            cout << m.at < float >(i, j) << ",";
        }
        cout << endl;
    }
}

void menu()
{
    cout << "\npressione a tecla para ativar o filtro: \n"
            "a - calcular modulo\n"
            "m - media\n"
            "g - gauss\n"
            "v - vertical\n"
            "h - horizontal\n" 
            "l - laplaciano\n"
            "x - laplaciano do gaussiano\n" 
            "esc - sair\n";
}

int main(int argvc, char **argv)
{
    VideoCapture video;
    float media[] = { 1, 1, 1,
                      1, 1, 1,
                      1, 1, 1
    };
    float gauss[] = { 1, 2, 1,
                      2, 4, 2,
                      1, 2, 1
    };
    float horizontal[] = { -1, 0, 1,
                           -2, 0, 2,
                            1, 0, 1
    };
    float vertical[] = {   -1, -2, -1,
                            0,  0,  0,
                            1,  2,  1
    };
    float laplacian[] = { 0, -1,  0,
                         -1,  4, -1,
                          0, -1,  0
    };
    
    // Aplicação da máscara "Laplaciano do Gaussiano", comum na literatura
    float x[]=  {0,  0,  -1,  0,  0,
                 0, -1,  -2, -1,  0,
                -1, -2,  16, -2, -1,
                 0, -1,  -2, -1,  0,
                 0,  0,  -1,  0,  0
    };

    Mat cap, frame, frame32f, frameFiltered;
    Mat mask(3, 3, CV_32F), mask1;
    Mat result, result1;
    double width, height, min, max;
    int absolut;
    char key;

    video.open(0);
    if (!video.isOpened())
        return -1;
    width = video.get(CV_CAP_PROP_FRAME_WIDTH);
    height = video.get(CV_CAP_PROP_FRAME_HEIGHT);
    std::cout << "largura=" << width << "\n";;
    std::cout << "altura =" << height << "\n";;

    namedWindow("filtroespacial", 1);

    mask = Mat(3, 3, CV_32F, media);
    scaleAdd(mask, 1 / 9.0, Mat::zeros(3, 3, CV_32F), mask1);
    swap(mask, mask1);
    absolut = 1;                // calcs abs of the image

    menu();
    for (;;) {
        video >> cap;
        resize(cap, cap, Size(640,360));
        cvtColor(cap, frame, CV_BGR2GRAY);
        flip(frame, frame, 1);
        imshow("original", frame);
        frame.convertTo(frame32f, CV_32F);        
        
        filter2D(frame32f, frameFiltered, frame32f.depth(), mask, Point(1, 1), 0);         
        
        if (absolut) {
            frameFiltered = abs(frameFiltered);
        }
        frameFiltered.convertTo(result, CV_8U);
        imshow("filtroespacial", result);
        key = (char) waitKey(10);
        if (key == 27)
            break;              // esc pressed!
        switch (key) {
        case 'a':
            menu();
            absolut = !absolut;
            break;
        case 'm':
            menu();
            mask = Mat(3, 3, CV_32F, media);
            scaleAdd(mask, 1 / 9.0, Mat::zeros(3, 3, CV_32F), mask1);
            mask = mask1;
            printmask(mask);
            break;
        case 'g':
            menu();
            mask = Mat(3, 3, CV_32F, gauss);
            scaleAdd(mask, 1 / 16.0, Mat::zeros(3, 3, CV_32F), mask1);
            mask = mask1;
            printmask(mask);
            break;
        case 'h':
            menu();
            mask = Mat(3, 3, CV_32F, horizontal);
            printmask(mask);
            break;
        case 'v':
            menu();
            mask = Mat(3, 3, CV_32F, vertical);
            printmask(mask);
            break;
        case 'l':
            menu();
            mask = Mat(3, 3, CV_32F, laplacian);
            printmask(mask);
            break;
            
        //Implementação do case para o "laplaciano do Gaussiano"
        case 'x':
            menu();
            mask = Mat(5, 5, CV_32F, x);
            printmask(mask);
            break;
        default:
            break;
        }
    }
    return 0;
}
     
                                    </code></pre>
                                </div>
                                
                                    <div class="section-block">
                                        <h6>Figura 9 - Captura Original</h6> 
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/6/original.png" alt="screenshot"></a>                                                
                                        </div>                   
                                    </div><!--//section-block-->
                                    
                                    <div class="section-block">
                                        <h6>Figura 10 - Captura com filtro Laplaciano</h6> 
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/6/laplaciano.png" alt="screenshot"></a>                                                
                                        </div>                   
                                    </div><!--//section-block-->
                                    
                                    <div class="section-block">
                                        <h6>Figura 11 - Captura com filtro Gaussiano</h6> 
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/6/gaussiano.png" alt="screenshot"></a>                                                
                                        </div>                   
                                    </div><!--//section-block-->  
                                    
                                    <div class="section-block">
                                        <h6>Figura 12 - Captura com filtro Laplaciano do Gaussiano</h6> 
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/6/laplgaus.png" alt="screenshot"></a>                                                
                                        </div>                   
                                    </div><!--//section-block-->                                      
                                    
                                    <p>
                                    Analizando os resultados, podemos verificar que o "Laplaciano do Gaussiano" deixa as bordas ainda mais aparente, em comparação ao filtro Laplaciano, entretanto, percebe-se mais ruidos.
                                    </p>
                                    
                                </div>

                                 <div id="step5"  class="section-block">
                                
                                    <h1 class="block-title">Exercício 7 - Filtragem no domínio espacial II</h1>
                                    <p><i>                                    
                                    Utilizando o programa <a href="PDI/7/addweighted.cpp">addweighted.cpp</a> como referência, implemente um programa <code>tiltshift.cpp</code>. Três ajustes deverão ser providos na tela da interface:

                                    <ul class="list">
                                        <li>um ajuste para regular a altura da região central que entrará em foco;</li>
                                        <li>um ajuste para regular a força de decaimento da região borrada;</li> 
                                        <li>um ajuste para regular a posição vertical do centro da região que entrará em foco. Finalizado o programa, a imagem produzida deverá ser salva em arquivo.</li>
                                    </ul> 

                                    </i></p> 
                                    <p>
                                    Independente de como o resultado é obtido (seja da maneira tradicional, através do uso de lentes especiais, ou por pós-produção digital), a aparência é a mesma graças ao desfoque local em algumas áreas específicas. O olho estranha esse desfoque, que não é natural para objetos e edifícios tão grandes e o cérebro acaba percebendo aquilo como uma miniatura.
                                    </p>
                                    <p>
                                    Utilizando o código de referência, foi desenvolvido o código para o tiltshift:
                                    </p>                   
                                 
                                    
                                    <div clas="code-block">
                                    <h6>Código: <a href="PDI/6/laplgauss.cpp">laplgauss.cpp</a></h6>
                                    <pre><code class="language-c++">
                                    
                                    
                                    </code></pre>
                                    </div>
                                    
                                    
                                    <div class="section-block">
                                        <h6>Figura 13 - Imagem com tiltshift</h6> 
                                        <div class="screenshot-holder">
                                            <a data-title="terminal" data-toggle="lightbox"><img class="img-responsive" 
                                            src="PDI/7/tiltshift.png" alt="screenshot"></a>                                                
                                        </div>                   
                                    </div><!--//section-block-->                                     
                                    
                                </div>
                                    
                                    
                                    
     
                            </section><!--//doc-section-->  
                            
                            
                            
                                                
                            <section id="2unidade-section" class="doc-section">
                                <h2 class="section-title">2ª Unidade</h2>
                                <div class="section-block">
                                    <p>
                                    
                                    </p>
                                    
                                </div><!--//section-block-->
                                <div id="html" class="section-block">                          

     
                                    
                                </div><!--//section-block-->
                                
                                

                            
                            </section><!--//doc-section-->
                            
                            
                            

                            <section id="3unidade-section" class="doc-section">
                                <h2 class="section-title">3ª Unidade</h2>
                                <div class="section-block">
                                    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi nec imperdiet turpis. Curabitur aliquet pulvinar ultrices. Etiam at posuere leo. Proin ultrices ex et dapibus feugiat <a href="#">link example</a> aenean purus leo, faucibus at elit vel, aliquet scelerisque dui. Etiam quis elit euismod, imperdiet augue sit amet, imperdiet odio. Aenean sem erat, hendrerit  eu gravida id, dignissim ut ante. Nam consequat porttitor libero euismod congue. 
                                    </p>
                                    

                                </div><!--//section-block-->
                            </section><!--//doc-section-->
                            
                            

                            <section id="icons-section" class="doc-section">
                                <h2 class="section-title">Plus</h2>
                                <div class="section-block">
                                    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi nec imperdiet turpis. Curabitur aliquet pulvinar ultrices. Etiam at posuere leo. Proin ultrices ex et dapibus feugiat <a href="#">link example</a> aenean purus leo, faucibus at elit vel, aliquet scelerisque dui. Etiam quis elit euismod, imperdiet augue sit amet, imperdiet odio. Aenean sem erat, hendrerit  eu gravida id, dignissim ut ante. Nam consequat porttitor libero euismod congue. 
                                    </p>
                                </div><!--//section-block-->
                                

                                
                            </section><!--//doc-section-->
                            
                            <section class="doc-section">
                                <h2 class="section-title"></h2>
                                <div id="disqus_thread"></div>
                                <script>

                                /**
                                *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                                *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
                                /*
                                var disqus_config = function () {
                                this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
                                this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                                };
                                */
                                (function() { // DON'T EDIT BELOW THIS LINE
                                var d = document, s = d.createElement('script');
                                s.src = 'https://danielmorais.disqus.com/embed.js';
                                s.setAttribute('data-timestamp', +new Date());
                                (d.head || d.body).appendChild(s);
                                })();
                                </script>
                                <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>  
                                
                                <script id="dsq-count-scr" src="//danielmorais.disqus.com/count.js" async></script>
                            
                            </section>
                            
                            </section><!--//doc-section-->
                        </div><!--//content-inner-->
                    </div><!--//doc-content-->
                    
                    
                    
                    
                    <div class="doc-sidebar hidden-xs">
                        <nav id="doc-nav">
                            <ul id="doc-menu" class="nav doc-menu" data-spy="affix">
                                <li>
                                    <a class="scrollto" href="#about-section">About</a>
                                </li>
                                <li>
                                    <a class="scrollto" href="#1unidade-section">1ª UNIDADE</a>
                                    <ul class="nav doc-sub-menu">
                                        <li><a class="scrollto" href="#step1">Exercício 3</a></li>
                                        <li><a class="scrollto" href="#step2">Exercício 4</a></li>
                                        <li><a class="scrollto" href="#step3">Exercício 5</a></li>
                                        <li><a class="scrollto" href="#step4">Exercício 6</a></li>
                                        <li><a class="scrollto" href="#step5">Exercício 7</a></li>
                                    </ul><!--//nav-->
                                </li>
                                <li>
                                    <a class="scrollto" href="#2unidade-section">2ª UNIDADE</a>
                                    <ul class="nav doc-sub-menu">
                                        <li><a class="scrollto" href="#step6"></a></li>

                                    </ul><!--//nav-->
                                </li>
                                <li><a class="scrollto" href="#3unidade-section">3ª UNIDADE</a>
                                    <ul class="nav doc-sub-menu">
                                        <li><a class="scrollto" href="#step7"></a></li>

                                    </ul><!--//nav-->                                
                                </li>

                            </ul><!--//doc-menu-->
                        </nav>
                    </div><!--//doc-sidebar-->
                </div><!--//doc-body-->              
            </div><!--//container-->
        </div><!--//doc-wrapper-->
        
        <div id="promo-block" class="promo-block">
            <div class="container">
                <div class="promo-block-inner">

                </div><!--//promo-block-inner-->  
            </div><!--//container-->
        </div><!--//promo-block-->
        
    </div><!--//page-wrapper-->
    
    <footer id="footer" class="footer text-center">
        <div class="container">
            <!--/* This template is released under the Creative Commons Attribution 3.0 License. Please keep the attribution link below when using for your own project. Thank you for your support. :) If you'd like to use the template without the attribution, you can check out other license options via our website: themes.3rdwavemedia.com */-->
            <small class="copyright">Designed by <a href="http://themes.3rdwavemedia.com/" target="_blank">Xiaoying Riley</a> and <a href="#">Daniel Morais</a> | 2017</small>
            
        </div><!--//container-->
    </footer><!--//footer-->
    
     
    <!-- Main Javascript -->          
    <script type="text/javascript" src="assets/plugins/jquery-1.12.3.min.js"></script>
    <script type="text/javascript" src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="assets/plugins/prism/prism.js"></script>    
    <script type="text/javascript" src="assets/plugins/jquery-scrollTo/jquery.scrollTo.min.js"></script>                                                                
    <script type="text/javascript" src="assets/plugins/jquery-match-height/jquery.matchHeight-min.js"></script>
    <script type="text/javascript" src="assets/js/main.js"></script>
    
</body>
</html> 

